{'--monitor_freq': '1000000',
 '--verbose': True,
 '<campaign_queue_algorithm>': 'fcfs',
 '<cores>': '3',
 '<decay>': None,
 '<input>': '../tmp/example4.ygn',
 '<output>': '../tmp/whitenoise',
 '<period_amount>': None,
 '<period_size>': None,
 '<scheduling_algorithm>': 'greedy',
 'slurm': False}
{'--monitor_freq': '1000000',
 '--verbose': True,
 '<campaign_queue_algorithm>': 'fcfs',
 '<cores>': '3',
 '<decay>': None,
 '<input>': '../tmp/example4.ygn',
 '<output>': '../tmp/whitenoise',
 '<period_amount>': None,
 '<period_size>': None,
 '<scheduling_algorithm>': 'greedy',
 'slurm': False}
[]
before computing utilization, hwstatus: []
CALLING SCHEDULE_BATCH_OF_JOBS at time 0 and utilization is [[0, 0]]
schedule_batch_of_jobs: Testing for job {user 0, id 1, walltime 3, cores 1} at time 0
does_it_fit call: t 0 job {user 0, id 1, walltime 3, cores 1} utilization [[0, 0]] cores 3
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 0]]
update_utilization call on job {user 0, id 1, walltime 3, cores 1} with utilization [[0, 0]] at time 0
schedule_batch_of_jobs: after utilization update: [[0, 1], [3, 0]]
schedule_batch_of_jobs: hole open, not touching x.
schedule_batch_of_jobs: Testing for job {user 0, id 4, walltime 2, cores 1} at time 0
does_it_fit call: t 0 job {user 0, id 4, walltime 2, cores 1} utilization [[0, 1], [3, 0]] cores 3
does_it_fit: Found a hole.
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 1], [3, 0]]
update_utilization call on job {user 0, id 4, walltime 2, cores 1} with utilization [[0, 1], [3, 0]] at time 0
schedule_batch_of_jobs: after utilization update: [[0, 2], [3, 0]]
schedule_batch_of_jobs: hole open, not touching x.
schedule_batch_of_jobs: Testing for job {user 0, id 49, walltime 1, cores 1} at time 0
does_it_fit call: t 0 job {user 0, id 49, walltime 1, cores 1} utilization [[0, 2], [3, 0]] cores 3
does_it_fit: Found a hole.
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 2], [3, 0]]
update_utilization call on job {user 0, id 49, walltime 1, cores 1} with utilization [[0, 2], [3, 0]] at time 0
schedule_batch_of_jobs: after utilization update: [[0, 3], [3, 0]]
schedule_batch_of_jobs: found new index 1
schedule_batch_of_jobs: found job,setting x because hole closed, previous x: 0, new x: 3
schedule_batch_of_jobs: Testing for job {user 0, id 50, walltime 1, cores 1} at time 3
does_it_fit call: t 3 job {user 0, id 50, walltime 1, cores 1} utilization [[0, 3], [3, 0]] cores 3
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 3], [3, 0]]
update_utilization call on job {user 0, id 50, walltime 1, cores 1} with utilization [[0, 3], [3, 0]] at time 3
schedule_batch_of_jobs: after utilization update: [[0, 3], [3, 1], [4, 0]]
schedule_batch_of_jobs: hole open, not touching x.
schedule_batch_of_jobs: Testing for job {user 0, id 51, walltime 1, cores 1} at time 3
does_it_fit call: t 3 job {user 0, id 51, walltime 1, cores 1} utilization [[0, 3], [3, 1], [4, 0]] cores 3
does_it_fit: Found a hole.
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 3], [3, 1], [4, 0]]
update_utilization call on job {user 0, id 51, walltime 1, cores 1} with utilization [[0, 3], [3, 1], [4, 0]] at time 3
schedule_batch_of_jobs: after utilization update: [[0, 3], [3, 2], [4, 0]]
schedule_batch_of_jobs: hole open, not touching x.
schedule_batch_of_jobs: Returning orders, utilization is [[0, 3], [3, 2], [4, 0]]
EXTENDING ORDERS at time 0 and utilization is [[0, 3], [3, 2], [4, 0]]
EXTENDING ORDERS at time 0 and utilization is [[0, 3], [3, 2], [4, 0]]
----------------RETURN_ORDERS:--------------------__
{{user 0, id 4, walltime 2, cores 1}: 0, {user 0, id 50, walltime 1, cores 1}: 3, {user 0, id 1, walltime 3, cores 1}: 0, {user 0, id 49, walltime 1, cores 1}: 0, {user 0, id 51, walltime 1, cores 1}: 3}
--------------------------------------------------__
[{user 0, id 4, walltime 2, cores 1}, {user 0, id 1, walltime 3, cores 1}]
before computing utilization, hwstatus: [{user 0, id 4, walltime 2, cores 1}, {user 0, id 1, walltime 3, cores 1}]
DADADA remaining walltime: 1
CALLING SCHEDULE_BATCH_OF_JOBS at time 2 and utilization is [[0, 2], [1, 0]]
schedule_batch_of_jobs: Testing for job {user 0, id 1, walltime 3, cores 1} at time 0
does_it_fit call: t 0 job {user 0, id 1, walltime 3, cores 1} utilization [[0, 2], [1, 0]] cores 3
does_it_fit: Found a hole.
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 2], [1, 0]]
update_utilization call on job {user 0, id 1, walltime 3, cores 1} with utilization [[0, 2], [1, 0]] at time 0
schedule_batch_of_jobs: after utilization update: [[0, 3], [1, 0]]
schedule_batch_of_jobs: found new index 1
schedule_batch_of_jobs: found job,setting x because hole closed, previous x: 0, new x: 1
schedule_batch_of_jobs: Testing for job {user 0, id 4, walltime 2, cores 1} at time 1
does_it_fit call: t 1 job {user 0, id 4, walltime 2, cores 1} utilization [[0, 3], [1, 0]] cores 3
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 3], [1, 0]]
update_utilization call on job {user 0, id 4, walltime 2, cores 1} with utilization [[0, 3], [1, 0]] at time 1
schedule_batch_of_jobs: after utilization update: [[0, 3], [1, 0]]
schedule_batch_of_jobs: hole open, not touching x.
schedule_batch_of_jobs: Testing for job {user 0, id 49, walltime 1, cores 1} at time 1
does_it_fit call: t 1 job {user 0, id 49, walltime 1, cores 1} utilization [[0, 3], [1, 0]] cores 3
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 3], [1, 0]]
update_utilization call on job {user 0, id 49, walltime 1, cores 1} with utilization [[0, 3], [1, 0]] at time 1
schedule_batch_of_jobs: after utilization update: [[0, 3], [1, 0]]
schedule_batch_of_jobs: hole open, not touching x.
schedule_batch_of_jobs: Testing for job {user 0, id 50, walltime 1, cores 1} at time 1
does_it_fit call: t 1 job {user 0, id 50, walltime 1, cores 1} utilization [[0, 3], [1, 0]] cores 3
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 3], [1, 0]]
update_utilization call on job {user 0, id 50, walltime 1, cores 1} with utilization [[0, 3], [1, 0]] at time 1
schedule_batch_of_jobs: after utilization update: [[0, 3], [1, 1], [2, 0]]
schedule_batch_of_jobs: hole open, not touching x.
schedule_batch_of_jobs: Testing for job {user 0, id 51, walltime 1, cores 1} at time 1
does_it_fit call: t 1 job {user 0, id 51, walltime 1, cores 1} utilization [[0, 3], [1, 1], [2, 0]] cores 3
does_it_fit: Found a hole.
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 3], [1, 1], [2, 0]]
update_utilization call on job {user 0, id 51, walltime 1, cores 1} with utilization [[0, 3], [1, 1], [2, 0]] at time 1
schedule_batch_of_jobs: after utilization update: [[0, 3], [1, 2], [2, 0]]
schedule_batch_of_jobs: hole open, not touching x.
schedule_batch_of_jobs: Returning orders, utilization is [[0, 3], [1, 2], [2, 0]]
EXTENDING ORDERS at time 2 and utilization is [[0, 3], [1, 2], [2, 0]]
EXTENDING ORDERS at time 2 and utilization is [[0, 3], [1, 2], [2, 0]]
CALLING SCHEDULE_BATCH_OF_JOBS at time 2 and utilization is [[0, 3], [1, 2], [2, 0]]
schedule_batch_of_jobs: Testing for job {user 1, id 15, walltime 5, cores 1} at time 0
does_it_fit call: t 0 job {user 1, id 15, walltime 5, cores 1} utilization [[0, 3], [1, 2], [2, 0]] cores 3
does_it_fit: Insufficient starting space.
schedule_batch_of_jobs: Job Doesn't Fit!
schedule_batch_of_jobs: Testing for job {user 1, id 24, walltime 4, cores 1} at time 0
does_it_fit call: t 0 job {user 1, id 24, walltime 4, cores 1} utilization [[0, 3], [1, 2], [2, 0]] cores 3
does_it_fit: Insufficient starting space.
schedule_batch_of_jobs: Job Doesn't Fit!
schedule_batch_of_jobs: Testing for job {user 1, id 26, walltime 1, cores 1} at time 0
does_it_fit call: t 0 job {user 1, id 26, walltime 1, cores 1} utilization [[0, 3], [1, 2], [2, 0]] cores 3
does_it_fit: Insufficient starting space.
schedule_batch_of_jobs: Job Doesn't Fit!
schedule_batch_of_jobs: no found job, previous x: 0, new x: 1
schedule_batch_of_jobs: Testing for job {user 1, id 15, walltime 5, cores 1} at time 1
does_it_fit call: t 1 job {user 1, id 15, walltime 5, cores 1} utilization [[0, 3], [1, 2], [2, 0]] cores 3
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 3], [1, 2], [2, 0]]
update_utilization call on job {user 1, id 15, walltime 5, cores 1} with utilization [[0, 3], [1, 2], [2, 0]] at time 1
schedule_batch_of_jobs: after utilization update: [[0, 3], [2, 1], [6, 0]]
schedule_batch_of_jobs: found new index 1
schedule_batch_of_jobs: found job,setting x because hole closed, previous x: 1, new x: 2
schedule_batch_of_jobs: Testing for job {user 1, id 24, walltime 4, cores 1} at time 2
does_it_fit call: t 2 job {user 1, id 24, walltime 4, cores 1} utilization [[0, 3], [2, 1], [6, 0]] cores 3
does_it_fit: Found a hole.
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 3], [2, 1], [6, 0]]
update_utilization call on job {user 1, id 24, walltime 4, cores 1} with utilization [[0, 3], [2, 1], [6, 0]] at time 2
schedule_batch_of_jobs: after utilization update: [[0, 3], [2, 2], [6, 0]]
schedule_batch_of_jobs: hole open, not touching x.
schedule_batch_of_jobs: Testing for job {user 1, id 26, walltime 1, cores 1} at time 2
does_it_fit call: t 2 job {user 1, id 26, walltime 1, cores 1} utilization [[0, 3], [2, 2], [6, 0]] cores 3
does_it_fit: Found a hole.
schedule_batch_of_jobs: Job Fits! updating utilization. before: [[0, 3], [2, 2], [6, 0]]
update_utilization call on job {user 1, id 26, walltime 1, cores 1} with utilization [[0, 3], [2, 2], [6, 0]] at time 2
schedule_batch_of_jobs: after utilization update: [[0, 3], [6, 0]]
schedule_batch_of_jobs: found new index 1
schedule_batch_of_jobs: found job,setting x because hole closed, previous x: 2, new x: 6
schedule_batch_of_jobs: Returning orders, utilization is [[0, 3], [6, 0]]
EXTENDING ORDERS at time 2 and utilization is [[0, 3], [6, 0]]
EXTENDING ORDERS at time 2 and utilization is [[0, 3], [6, 0]]
----------------RETURN_ORDERS:--------------------__
{{user 1, id 15, walltime 5, cores 1}: 1, {user 0, id 1, walltime 3, cores 1}: 0, {user 1, id 24, walltime 4, cores 1}: 2, {user 0, id 4, walltime 2, cores 1}: 1, {user 0, id 49, walltime 1, cores 1}: 1, {user 1, id 26, walltime 1, cores 1}: 2, {user 0, id 50, walltime 1, cores 1}: 1, {user 0, id 51, walltime 1, cores 1}: 1}
--------------------------------------------------__
[{user 1, id 15, walltime 5, cores 1}, {user 1, id 24, walltime 4, cores 1}]
before computing utilization, hwstatus: [{user 1, id 15, walltime 5, cores 1}, {user 1, id 24, walltime 4, cores 1}]
btw time is 8
